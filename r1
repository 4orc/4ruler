#!/usr/bin/env lua
---                _     
---              /' \    
---    _ __     /\_, \   
---   /\`'__\   \/_/\ \  
---   \ \ \/       \ \ \ 
---    \ \_\        \ \_\
---     \/_/         \/_/

local the,help = {},[[
R1: rule generation for multi-objective optimization
(c) 2022, Tim Menzies, <timm@ieee.org>, BSD-2 clause

"Four years ago I couldn't even say 
 'knowledge engineer", now I ..." -- John McDermott

USAGE: 
  r1  [OPTIONS]  [-f file.csv]

OPTIONS: 
  -b --best    ratio of "best" examples     = .2
  -B --Bins    max number of bins           = 16
  -c --cohen   Cohen's small d size         = .35
  -d --dump    stop on errors, dump stack   = false
  -f --file    data file                    = ../data/auto93.csv
  -g --go      start-up action              = nothing
  -G --Goal    one of (up,down,other,mid)   = up
  -h --help    show help                    = false
  -p --p       distance coefficient         = 2
  -r --repeats sample size for rows         = 256
  -s --seed    random number seed           = 10019]]

-- ## Coding Conventions 
-- -- Less than 100 characters per line (and tabs are two spaces).
-- -- The `end` keywords appear at end of line, after some code.
-- -- The `the` variable contains program settings:
--    -- These settings parsed out of the help file.
--    -- Settings can be changed on the command line using the first letter of the setting. 
--       -- e.g. `Bins` can be changed via e.g. `-B 20`;
--    -- Boolean settings can be changed just be mentioning them on the command line. 
--      -- e.g. the default of `help` = `false` is changed to `true` via `-h`.
-- -- The `eg` table contains tests. 
--    -- If tests return `false`, they are a failure.
--    -- On exit, this code returns the total number of failires
--    -- Any test `eg.x()` can be called from command line using `-g x`
--    -- All tests can be called from the command line using `-g all`.
-- -- Any line starting with "-- " is part of the README documentation.
-- -- Public functions and methods are denoted with `;-->type;help`. for such items:
--    -- Optional vars denoted with 2 leading blanks
--    -- Local vars denoted with 4 leading blanks
-- -- Class construction methods  denoted with CLASS:new and can be called CLASS().
-- -- Public item arguments contain some basic type hints:
--    -- Lower case versions of class names are instances (eg. data1 is of class DATA)
--    -- `x` or `any` denotes anything at all
--    -- `t` denotes a table 
--    -- prefix `n`  denotes numbers
--    -- prefix `is` denotes booleans
--    -- prefix `s`  denotes strings
--    -- suffix `s` denotes list of things (e.g. `sfiles is a list of strings)
--    -- suffix `fun` denotes a function

local b4={}; for k,v in pairs(_ENV) do b4[k]=v end
-- ## Library
-- ### Maths
local big
big=math.huge

-- ### Strings to Things
local coerce,csv
function coerce(s) --> any; return int or float or bool or string from `s`
  local function fun(s1)
    if s1=="true"  then return true  end
    if s1=="false" then return false end
    return s1 end
  return math.tointeger(s) or tonumber(s) or fun(s:match"^%s*(.-)%s*$") end

function csv(sFilename,fun) --> nil; call `fun` on rows (after coercing cell text)
  local src,s,t  = io.input(sFilename)
  while true do
    s = io.read()
    if   s
    then t={}; for s1 in s:gmatch("([^,]+)") do t[1+#t]=coerce(s1) end; fun(t)
    else return io.close(src) end end end

-- ### Lists
local any,copy,push,map,keys,gt,lt,sort,list
function any(t)
  return t[math.random(#t)] end

function push(t, x) --> any; push `x` to end of list; return `x` 
  table.insert(t,x); return x end

function map(t, fun) --> t; map function `fun`(v) over list (skip nil results) 
  local u={}; for _,v in pairs(t)do u[1+#u]=fun(v) end;return u end

function keys(t) --> t; sort+return `t`'s keys (ignore things with leading `_`)
  local function want(k,x) if tostring(k):sub(1,1) ~= "_" then return k end end
  local u={}; for k,v in pairs(t) do if want(k) then u[1+#u] = k end end
  return sort(u) end

function lt(x)
  return function(a,b) return a[x] < b[x] end end

function gt(x)
  return function(a,b) return a[x] > b[x] end end

function sort(t,fun)
  table.sort(t,fun); return t end

function copy(t) --> t; return a deep copy of `t.
  if type(t) ~= "table" then return t end
  local u={}; for k,v in pairs(t) do u[k] = copy(v) end
  return setmetatable(u,getmetatable(t))  end

function list(t)
  local u={}; for _,x in pairs(t) do u[1+#u]=x end; return u end

-- ### Printing
local fmt,oo,o
function fmt(sControl,...) --> str; emulate printf
  return string.format(sControl,...) end

function oo(t) --> t; print `t`'s string (the one generated by `o`)
  print(o(t)); return t end

function o(t,  seen) --> str; table to string (recursive)
  if type(t) ~= "table" then return tostring(t) end
  local pre = t._is and fmt("%s_%s",t._is,t._id or "") or ""
  seen=seen or {}
  if seen[t] then return fmt("<%s>",pre) end
  seen[t] = t
  local function filter(k) return fmt(":%s %s",k,o(t[k],seen)) end
  local u = #t>0 and map(t,tostring) or map(keys(t),filter)
  return pre.."{".. table.concat(u," ").."}" end

-- ### Polymorphism
local _id,id,obj=0
function obj(s,    t,new) --> t; create a klass, with a constructor + print method
  local function new(k,...) 
     _id = _id + 1
     local i=setmetatable({_id=_id},k); t.new(i,...); return i end
  t={_is=s, __tostring = o}
  t.__index = t;return setmetatable(t,{__call=new}) end
--------------------------------------------------------------------------------
-- ## Objects
-- ### NUM
local NUM=obj"NUM"
function NUM:new(n,s) 
  self.at  = n or 0
  self.txt = s or ""
  self.p   = {}
  self.w   = self.txt:find"-$" and -1 or 1
  self.n, self.mu, self.m2 = 0, 0, 0
  self.lo, self.hi= big, -big end

function NUM:add(x)
  if x ~= "?" then
    self.n  = self.n + 1
    local d = x - self.mu
    self.mu = self.mu + d/self.n
    self.m2 = self.m2 + d*(x - self.mu)
    self.sd = (self.m2 <0 or self.n < 2) and 0 or (self.m2/(self.n-1))^0.5 
    self.lo = math.min(x, self.lo)
    self.hi = math.max(x, self.hi) end end

function NUM:norm(x)
  if x=="?" then return x end 
  local lo,hi=self.lo,self.hi
  return (hi - lo) < 1E-9 and 0 or (x - lo)/(hi - lo) end

function NUM:discretize(x) --> num; discretize `Num`s,rounded to (hi-lo)/bins
  local lo,hi=self.lo,self.hi
  local tmp = (hi - lo)/(the.Bins - 1)
  return hi == lo and 1 or math.floor(x/tmp + .5)*tmp end 

function NUM:dist(x,y)
  if x=="?" and y=="?" then return 1 end
  x,y = self:norm(x), self:norm(y)
  if x=="?" then x = y<.5 and 1 or 0 end
  if y=="?" then y = x<.5 and 1 or 0 end
  return math.abs(x - y) end

function NUM:merge(b4,min) 
  local function fillInTheGaps(t)
    for j=2,#t do t[j-1].hi = t[j].lo end
    t[1 ].lo = -big
    t[#t].hi =  big
    return t 
  end ------
  local now,j = {},1
  while j <= #b4 do
    local xy1, xy2 = b4[j], b4[j+1]
    local merged   = xy2 and xy1:merge(xy2,min, the.cohen*self.sd)
    now[1+#now]    = merged or xy1
    j              = j + (merged and 2 or 1) end 
  return #now < #b4 and self:merge(now,min) or fillInTheGaps(now) end 
--------------------------------------------------------------------------------
-- ### SYM
local SYM=obj"SYM"
function SYM:new(n,s)
  self.at  = n or 0
  self.txt = s or ""
  self.n   = 0
  self.has = {}
  self.most, self.mode = 0,nil
  self.p   = {} end

function SYM:add(x) 
  if x ~= "?" then 
   self.n = self.n + 1 
   self.has[x] = 1 + (self.has[x] or 0)
   if self.has[x] > self.most then
     self.most,self.mode = self.has[x], x end end end 

function SYM:norm(x) return x end
function SYM:merge(x,...) return x end
function SYM:discretize(x) return x end

function SYM:dist(x,y) 
  return x=="?" and y=="?" and 1 or (x==y and 0 or 1) end


--------------------------------------------------------------------------------
--- ### XY
local XY=obj"XY"
function XY:new(at,txt,lo,hi) 
  self.at = at
  self.txt= txt
  self.n, self.p = 0,0
  self._rows={}
  self.lo=lo
  self.hi=hi or lo end

function XY:add(x,p,row)
  self._rows[row._id] = row
  self.n  = self.n + 1
  self.p  = self.p + p
  self.lo = math.min(x, self.lo)
  self.hi = math.max(x, self.hi) end

function XY:merge(xy,rare,small)
  local a,b = self, xy
  local c   = XY(self.at, self.txt, a.lo, b.hi)
  c.p = a.p + b.p
  c.n = a.n + b.n
  for k,v in pairs(a._rows) do c._rows[k] = v end 
  for k,v in pairs(b._rows) do c._rows[k] = v end
  local isRare  = a.n< rare or b.n <= rare
  local isSmall = b.lo - a.lo <= small 
  if isSmall or isRare then return c end end

function XY:select(row)
  if self.rows[row._id] then return row end -- we've seen it before and we like it
  local x=row.cells[self.at]
  if  x == "?"                           then return row end -- if in doubt, return it
  if self.lo < x and x <= self.hi        then return row end -- for numbers
  if self.lo == self.hi and x == self.lo then return row end -- for symbols
  end

function XY:selects(rows)
  return map(row, function(row) return self:select(row) end) end

-- function selects(xys,rows)
--   local ors={}
--   for _,xy in pairs(xys) do 
--     ors[xy.at]=ors[xy.at] or {}
--     push(ors[xy.at], xy) end
--   local ands = {}
--   for n,xys in pairs(ors) do
--     local or1={}
--     for _,xy in pairs(self:selects(row)) do or[xy:selects(rows,or1) end
--     if n==1 then ands=tmp else
--       for id,row in pairs(tmp) do
--          if 
--------------------------------------------------------------------------------
-- ### COLS
local COLS=obj"COLS"
function COLS:new(t)
  self.names, self.all, self.x, self.y = t,{},{},{} 
  for n,s in pairs(t) do 
    local col = push(self.all, s:find"^[A-Z]+" and NUM(n,s) or SYM(n,s))
    if not s:find"X$" then
      push(s:find"[!+-]$" and self.y or self.x, col) end end end
    
function COLS:add(row)
  for _,cols in pairs{self.x, self.y} do
    for _,col in pairs(cols) do
      col:add(row.cells[col.at]) end end 
  return row end
--------------------------------------------------------------------------------
-- ### ROW
local ROW=obj"ROW"
function ROW:new(t,data) 
  self.cells=t; self._data=data end

function ROW:__lt(row)
  local ys= self._data.cols.y
  local s1,s2,n,x,y = 0,0,#ys
  for _,col in pairs(ys) do
    x  = col:norm( self.cells[col.at] )
    y  = col:norm( row.cells[col.at]  )
    s1 = s1 - math.exp(col.w * (x-y)/n)
    s2 = s2 - math.exp(col.w * (y-x)/n) end
  return s1/n < s2/n end

function ROW:__sub(row) return self:dist(row, self._data.cols.x) end
function ROW:dist(row,cols)
  cols = cols or self._data.cols.x
  local d = 0
  for _,col in pairs(cols) do
    local x,y = self.cells[col.at], row.cells[col.at]
    d = d + col:dist(x,y)^the.p end
  return (d/#cols)^(1/the.p) end
--------------------------------------------------------------------------------
-- ### DATA
local DATA,data = obj"DATA"

function data(from) ;--> DATA; factory for making from files or lists
  local data1
  local function add(t) if not data1 then data1=DATA(t) else data1:add(t) end end
  if type(from)=="string" then csv(from, add) else map(from or {}, add) end
  return data1 end

function DATA:new(t,src)
  self.rows,self.cols ={},COLS(t) end

function DATA:add(t) 
  push(self.rows,                    -- add a new row to `rows`
        self.cols:add(                -- update column readers (returns the row)
          t.cells and t or ROW(t,self) -- ensure thing being added is a ROW
          )) end

function DATA:betters() return sort(self.rows) end

function DATA:reward(row1,row2)
  io.write(".")
  if row2 < row1 then row1,row2 = row2,row1 end
  local weight = row1:dist(row2, self.cols.y)
  for _,col in pairs(self.cols.x) do
    local x = row1.cells[col.at]
    if x ~= "?" then 
      local v  = col:discretize(x)
      col.p[v] = col.p[v] or XY(col.at, col.txt, x)
      col.p[v]:add(x, weight,row1) end end end 

function DATA:rewards()
  for j=1,the.repeats do self:reward(any(self.rows), any(self.rows)) end
  local out = {}
  for _,col in pairs(self.cols.x) do
    print""
    local xys = sort(list(col.p), lt"lo")
    xys = col:merge(xys, #self.rows/the.Bins)
    for _,xy in pairs(xys) do 
         push(out, xy) end end 
  return sort(out,gt"p") end
--------------------------------------------------------------------------------
-- ### Start-up stuff
local cli,main,runs,run1
function cli(options) --> t; update key,vals in `t` from command-line flags
  for k,v in pairs(options) do
    local v=tostring(v)
    for n,x in ipairs(arg) do
      if x=="-"..(k:sub(1,1)) or x=="--"..k then
         v = v=="false" and "true" or v=="true" and "false" or arg[n+1] end end
    options[k] = coerce(v) end
  return options end

function run1(options,fun) -->x; reset seed; call `fun`; afterwards, reset config
  local was=copy(options)
  math.randomseed(options.seed or 10019)
  local status, result
  if options.dump then 
    status,result=true, fun() 
  else
    status,result=pcall(fun) -- do not crash and dump on errror
  end
  for k,v in pairs(was) do options[k]=v end -- undo any changes to the config
  if not status then return false else return result end end

function runs(options,funs)
  local fails = 0
  for _,k in pairs(keys(funs)) do              
    if options.go == "all" or options.go==k then 
      if   run1(options, funs[k]) == false      
      then print(fmt("FAIL ❌ %s",k))
           fails = fails + 1                 
      else print(fmt("PASS ✅ %s",k)) end end end 
  return fails end

function main(help, options,funs)
  help:gsub("\n[%s]+[-][%S]+[%s]+[-][-]([%S]+)[^\n]+= ([%S]+)",
            function(k,v) options[k] = coerce(v) end) 
  cli(options)
  if options.help then os.exit(print(fmt("\n%s\n",help))) end
  local fails = runs(options,funs)
  for k,v in pairs(_ENV) do 
    if not b4[k] then print(fmt("#W ?%s %s",k,type(v))) end end 
  os.exit(fails) end
--------------------------------------------------------------------------------
local eg={}
function eg.the() oo(the) end

function eg.data() 
  local d= data(the.file) 
  map(d.cols.x,oo)
  oo(d.rows[1]) end

function eg.betters() 
  local d= data(the.file) 
  d:betters()
  oo(d.cols.names)
  for i=1,#d.rows,90 do 
    print(o(d.rows[i].cells),":",i) end end

function eg.xdist() 
  local d= data(the.file) 
  local c=d.rows[1]
  oo(d.cols.names)
  oo(c.cells)
  sort(d.rows, function(a,b) return c-a < c-b end)
  for i=1,#d.rows,90 do 
    print(o(d.rows[i].cells),":",fmt("%.3f",d.rows[i]-c)) end end

function eg.ydist() 
  local d= data(the.file) 
  local c=d.rows[1]
  oo(d.cols.names)
  oo(c.cells)
  local function dist(row) return row:dist(c, d.cols.y) end
  sort(d.rows, function(a,b) return dist(a) < dist(b) end)
  for i=1,#d.rows,90 do 
    print(o(d.rows[i].cells),":",fmt("%.3f",dist(d.rows[i]))) end end

function eg.rewards()
  local d=data(the.file)
  map(d:rewards(),print)
  -- for _,col in pairs(d.cols.x) do
  --   print""
  --   map(col.p,oo) end 
end

main(help,the,eg)


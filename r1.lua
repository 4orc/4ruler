#!/usr/bin/env lua
---          _       ___                        
---        /' \     /\_ \                       
---  _ __ /\_, \    \//\ \    __  __     __     
--- /\`'__\/_/\ \     \ \ \  /\ \/\ \  /'__`\   
--- \ \ \/   \ \ \  __ \_\ \_\ \ \_\ \/\ \L\.\_ 
---  \ \_\    \ \_\/\_\/\____\\ \____/\ \__/.\_\
---   \/_/     \/_/\/_/\/____/ \/___/  \/__/\/_/

local the,help = {},[[

R1: rule generation for multi-objective optimization
(c)2022, Tim Menzies, <timm@ieee.org>, BSD-2 clause

"Four years ago I couldn't even say 
 'knowledge engineer", now I ..." -- John McDermott

OPTIONS: 
 -b --best   ratio of "best" examples     = .2
 -B --Bins   max number of bins           = 16
 -f --file   data file                    = ../data/auto93.csv
 -g --go     start-up action              = nothing
 -G --Goal   one of (up,down,other,mid)   = up
 -h --help   show help                    = false
 -r --repeats sample size for rows        = 256
 -s --seed   random number seed           = 10019
 -S --Some   number of items kept in SOME = 256
]]
--------------------------------------------------------------------------------
local b4={}; for k,v in pairs(_ENV) do b4[k]=v end
-- ## Library
-- ### Maths
local big
big=math.huge

-- ### Strings to Things
local coerce,csv
function coerce(s) --> any; return int or float or bool or string from `s`
  local function fun(s1)
    if s1=="true"  then return true  end
    if s1=="false" then return false end
    return s1 end
  return math.tointeger(s) or tonumber(s) or fun(s:match"^%s*(.-)%s*$") end

function csv(sFilename,fun) --> nil; call `fun` on rows (after coercing cell text)
  local src,s,t  = io.input(sFilename)
  while true do
    s = io.read()
    if   s
    then t={}; for s1 in s:gmatch("([^,]+)") do t[1+#t]=coerce(s1) end; fun(t)
    else return io.close(src) end end end

-- ### Lists
local any,copy,push,map,keys,gt,lt,sort
function any(t)
  return t[math.random(#t)] end

function push(t, x) --> any; push `x` to end of list; return `x` 
  table.insert(t,x); return x end

function map(t, fun) --> t; map function `fun`(v) over list (skip nil results) 
  local u={}; for i,v in pairs(t)do u[1+#u]=fun(v) end;return u end

function keys(t) --> t; sort+return `t`'s keys (ignore things with leading `_`)
  local function want(k,x) if tostring(k):sub(1,1) ~= "_" then return k end end
  local u={}; for k,v in pairs(t) do if want(k) then u[1+#u] = k end end
  return sort(u) end

function lt(x)
  return function(a,b) return a[x] < b[x] end end

function gt(x)
  return function(a,b) return a[x] > b[x] end end

function sort(t,fun)
  table.sort(t,fun); return t end

function copy(t) --> t; return a deep copy of `t.
  if type(t) ~= "table" then return t end
  local u={}; for k,v in pairs(t) do u[k] = copy(v) end
  return setmetatable(u,getmetatable(t))  end

-- ### Printing
local fmt,oo,o
function fmt(sControl,...) --> str; emulate printf
  return string.format(sControl,...) end

function oo(t) --> t; print `t`'s string (the one generated by `o`)
  print(o(t)); return t end

function o(t,  seen) --> str; table to string (recursive)
  if type(t) ~= "table" then return tostring(t) end
  seen = seen or {}
  if seen[t] then return fmt("...") end
  seen[t] = t
  local function filter(k) return fmt(":%s %s",k,o(t[k],seen)) end
  local u = #t>0 and map(t,tostring) or map(keys(t),filter)
  return "{".. table.concat(u," ").."}" end

-- ### Polymorphism
local _id,id,obj=0
function obj(s,    t,new) --> t; create a klass, with a constructor + print method
  local function new(k,...) 
     _id = _id + 1
     local i=setmetatable({_id=_id},k); t.new(i,...); return i end
  t={_is=s, __tostring = o}
  t.__index = t;return setmetatable(t,{__call=new}) end

-- ### Start-up stuff
local cli,main,runs,run1
function cli(options) --> t; update key,vals in `t` from command-line flags
  for k,v in pairs(options) do
    local v=tostring(v)
    for n,x in ipairs(arg) do
      if x=="-"..(k:sub(1,1)) or x=="--"..k then
         v = v=="false" and "true" or v=="true" and "false" or arg[n+1] end end
    options[k] = coerce(v) end
  return options end

function run1(options,fun) -->x; reset seed; call `fun`; afterwards, reset config
  local was=copy(options)
  math.randomseed(options.seed or 10019)
  local status, result
  if options.dump then 
    status,result=true, fun() 
  else
    status,result=pcall(fun) -- do not crash and dump on errror
  end
  for k,v in pairs(was) do options[k]=v end -- undo any changes to the config
  if not status then return false else return result end end

function runs(options,funs)
  local fails = 0
  for _,k in pairs(keys(funs)) do              
    if options.go == "all" or options.go==k then 
      if   run1(options, funs[k]) == false      
      then print(fmt("FAIL ❌ %s",k))
           fails = fails + 1                 
      else print(fmt("PASS ✅ %s",k)) end end end 
  return fails end

function main(help, options,funs)
  help:gsub("\n [-][%S]+[%s]+[-][-]([%S]+)[^\n]+= ([%S]+)",
            function(k,v) options[k] = coerce(v) end) 
  cli(options)
  if options.help then os.exit(print(help)) end
  local fails = runs(options,funs)
  for k,v in pairs(_ENV) do 
    if not b4[k] then print(fmt("#W ?%s %s",k,type(v))) end end 
  os.exit(fails) end
--------------------------------------------------------------------------------
-- ## Objects
-- ### NUM
local NUM=obj"NUM"
function NUM:new(n,s) 
  self.at=n or 0
  self.txt = s or ""
  self.f, self.p = {},{}
  self.w=self.txt:find"-$" and -1 or 1
  self.lo, self.hi= big, -big end

function NUM:add(x)
  if x ~= "?" then
    self.lo = math.min(x, self.lo)
    self.hi = math.max(x, self.hi) end end

function NUM:norm(x)
  local lo,hi=self.lo,self.hi
  return (hi - lo) < 1E-9 and 0 or (x - lo)/(hi - lo) end

function NUM:discretize(x) --> num; discretize `Num`s,rounded to (hi-lo)/bins
  local lo,hi=self.lo,self.hi
  local tmp = (hi - lo)/(the.bins - 1)
  return hi == lo and 1 or math.floor(x/tmp + .5)*tmp end 
--------------------------------------------------------------------------------
-- ### SYM
local SYM=obj"SYM"
function SYM:new(n,s)
  self.at=n or 0
  self.txt = s or ""
  self.f, self.p = {},{} end

function SYM:add(x) return x end
function SYM:norm(x) return x end
function SYM:discretize(x) return x end
--------------------------------------------------------------------------------
--- ### XY
local XY=obj"XY"
function XY:new(at,txt,lo,hi) 
  self.at = at
  self.txt= txt
  self.n, self.p= 0,0
  self.lo=lo
  self.hi=hi or lo end

function XY:add(x,p)
  self.n = self.n+1
  self.p = self.p+1
  self.lo = math.min(x, self.lo)
  self.hi = math.max(x, self.hi) end

function XY:merge(xy,min)
  local a,b = self,xy
  local c = XY(a.at,a,txt, a.lo, b.hi)
  c.p = a.p + b.p
  c.n = a.n + b.n
  local smalln = a.n < min or b.n < min
  local dullp = (a.p*a.n + b.p*b.n)/c.n <= new.p
  if smalln or dullp then return merged end end

--------------------------------------------------------------------------------
-- ### COLS
local COLS=obj"COLS"
function COLS:new(t)
  self.all, self.x, self.y = {},{},{} 
  for n,s in pairs(t) do 
    local col = push(self.all, s:find"^[A-Z]+" and NUM(n,s) or SYM(n,s))
    if not s:find"X$" then
      push(s:find"[!+-]$" and self.y or self.x, col) end end end
    
function COLS:add(t)
  for _,cols in pairs{self.cols.x, self.cols.y} do
    for _,col in pairs(cols) do
      col:add(t.cells[col.at]) end end 
  return t end
--------------------------------------------------------------------------------
-- ### ROW
local ROW=obj"ROW"
function ROW:new(t,data) 
  self.cells=t; self.data=data end

function ROW:__lt(row)
  local ys= self.data.cols.y
  local s1,s2,n,x,y = 0,0,#ys
  for _,col in pairs(ys) do
    x  = col:norm( self.cells[col.at] )
    y  = col:norm( row.cells[col.at]  )
    s1 = s1 - math.exp(col.w * (x-y)/n)
    s2 = s2 - math.exp(col.w * (y-x)/n) end
  return s1/n < s2/n end
--------------------------------------------------------------------------------
-- ### DATA
local DATA=obj"DATA"
function DATA:new(t,src)
  self.rows,self.cols ={},COLS(t) end

function DATA:add(t) 
  local row  = t.cells and t or ROW(t,self)
  self.cols:add(row)
  push(data.rows, row) end

function data(from) ;--> DATA; factory for making from files or lists
  local data1
  local function add(t) if not data1 then data1=DATA(t) else data1:add(t) end end
  if type(from)=="string" then csv(from, add) else map(from or {}, add) end
  return data1 end
--------------------------------------------------------------------------------
local bins,merge,merges,rewards,reward
function merge(xy1,xy2)
  local min = 1/the.bins
  if xy2 then
    if xy1.p<min or xy2.p<min then
      return {txt=xy1.txt,at=xy1.at, 
              lo=xy1.lo, hi=xy2.hi, p=xy1.p + xy2.p}  end end end

function merges(b4)
  local now,j={},1
  while j <= #b4 do
    local xy1,xy2 = b4[j],b4[j+1]
    merged        = merge(xy1,xy2)
    now[1+#now]   = merged or xy1
    j             = j + (merged and 2 or 1) end 
  return #now == #b4 and b4 or merges(now) end 

function bins(col)
  local xy = {}
  for x,p in pairs(col.p) do 
    push(xy,{lo=x,hi=x,at=col.at, txt=col.txt, p=p}) end
  xy= sort(xy,lt"lo") 
  if col.nump then
    for j=2,#xy do xy[j-1].hi = xy[j].lo end
    xy[1  ].lo = -big
    xy[#xy].hi =  big
  end
  return #xy > 1 and xy or {}  end

function reward(row,data)
  for _,col in pairs(data.cols.x) do
    local x = row[col.at]
    if x ~= "?" then 
      local v = discretize(col,x)
      col.p[v] = 1/the.repeats + (col.p[v] or 0) end end end

function rewards(data)
  for _,col in pairs(data.cols.x) do
    if col.nump then
      for x = col.lo, col.hi, (col.hi - col.lo)/the.bins do 
        col.p[discretize(col,x)]=0 end end end
  for j=1,the.repeats do
    local row1, row2 = any(data.rows), any(data.rows)
    reward( better(row1,row2,data) and row1 or row2, data) end end
--------------------------------------------------------------------------------
local eg={}

function eg.the() oo(the) end

function eg.data() data(the.file) end

function eg.rewards(data1)
  data1=data(the.file)
  oo(data1.cols.x) 
  rewards(data1)
  local tmp ={}
  for _,col in pairs(data1.cols.x) do
    for _,x in pairs(merges(bins(col))) do push(tmp,x) end end
  for _,x in pairs(sort(tmp,gt"p")) do oo(x) end end

main(help,the,eg)


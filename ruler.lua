local the,help={},[[
RULER: return best rule

 -f --file   data file                    = ../data/auto93.csv
 -g --go     start-up action              = nothing
 -h --help   show help                    = false
 -s --seed   random number seed           = 937162211
 -S --Some   number of items kept in SOME = 256
]]
local b4={}; for k,v in pairs(_ENV) do b4[k]=v end
--------------------
-- ## Lib
-- ### Lists
local copy,keys,push
function copy(t) --> t; return a deep copy of `t.
  if type(t) ~= "table" then return t end
  local u={}; for k,v in pairs(t) do u[k] = copy(v) end
  return setmetatable(u,getmetatable(t))  end

function keys(t) --> t; sort+return `t`'s keys (ignore things with leading `_`)
  local function want(k,x) if tostring(k):sub(1,1) ~= "_" then return k end end
  local u={}; for k,v in pairs(t) do if want(k) then u[1+#u] = k end end
  table.sort(u)
  return u end

 function push(t, x) --> any; push `x` to end of list; return `x` 
  table.insert(t,x); return x end

-- ### Strings to things
local coerce, csv
function coerce(s) --> any; return int or float or bool or string from `s`
  local function fun(s1)
    if s1=="true"  then return true  end
    if s1=="false" then return false end
    return s1 end
  return math.tointeger(s) or tonumber(s) or fun(s:match"^%s*(.-)%s*$") end

function csv(sFilename,fun) --> nil; call `fun` on rows (after coercing cell text)
  local src,s,t  = io.input(sFilename)
  while true do
    s = io.read()
    if   s
    then t={}; for s1 in s:gmatch("([^,]+)") do t[1+#t]=coerce(s1) end; fun(t)
    else return io.close(src) end end end

-- ### Meta
local kap,map
function kap(t, fun) --> t; map function `fun`(k,v) over list (skip nil results) 
  local u={}; for k,v in pairs(t)do u[k]=fun(k,v) end; return u end

function map(t, fun) --> t; map function `fun`(v) over list (skip nil results) 
  local u={}; for i,v in pairs(t)do u[1+#u]=fun(v) end;return u end

-- ### Printing
local fmt,oo,o
function fmt(sControl,...) --> str; emulate printf
  return string.format(sControl,...) end

function oo(t) --> t; print `t`'s string (the one generated by `o`)
  print(o(t)); return t end

function o(t,  seen) --> str; table to string (recursive)
  if type(t) ~= "table" then return tostring(t) end
  local pre = t._is and fmt("%s%s",t._is,t._id or "") or ""
  seen=seen or {}
  if seen[t] then return fmt("<%s>",pre) end
  seen[t]=t
  local function filter(k) return fmt(":%s %s",k,o(t[k],seen)) end
  local u   = #t>0 and map(t,tostring) or map(keys(t),filter)
  return pre.."{".. table.concat(u," ").."}" end

-- ### Random numbers
local Seed,rand,rint,srand

Seed=937162211
function rand(nlo,nhi) --> num; return float from `nlo`..`nhi` (default 0..1)
  nlo, nhi = nlo or 0, nhi or 1
  Seed = (16807 * Seed) % 2147483647
  return nlo + (nhi-nlo) * Seed / 2147483647 end

function rint(nlo,nhi)  --> int; returns integer from `nlo`..`nhi` (default 0..1)
  return math.floor(0.5 + rand(nlo,nhi)) end

function srand(n)  --> nil; reset random number seed (defaults to 937162211) 
  Seed = n or 937162211 end

-- ### Objects
local _id,id,obj
_id=0
function id() _id=_id+1; return _id end

function obj(s,    t,new) --> t; create a klass and a constructor + print method
  local function new(k,...) 
     local i=setmetatable({_id=id()},k); t.new(i,...); return i end
  t={_is=s, __tostring = o}
  t.__index = t;return setmetatable(t,{__call=new}) end

-- ### Main control
local cli,run, runs
function cli(t) --> t; alters contents of options in `t` from the  command-line
  for k,v in pairs(t) do
    local v=tostring(v)
    for n,x in ipairs(arg) do
      if x=="-"..(k:sub(1,1)) or x=="--"..k then
         v = v=="false" and "true" or v=="true" and "false" or arg[n+1] end end
    t[k] = coerce(v) end
  if t.help then os.exit(print("\n"..help)) end
  return t end

function run(fun) -->x; reset seed; call `fun`; afterwards, reset config
  local was=copy(the)
  srand(the.seed)
  local result=fun()
  for k,v in pairs(was) do the[k]=v end -- undo any changes to the config
  return result end

function runs(t,funs)
  help:gsub("\n [-][%S]+[%s]+[-][-]([%S]+)[^\n]+= ([%S]+)",
            function(k,v) the[k]=coerce(v) end)
  cli(the)
  local fails = 0
  for _,k in pairs(keys(funs)) do                 -- for all functions
    if t.go == "all" or t.go==k then                -- if we want to run it...
      if run(funs[k]) == false                         -- if anything fails
        then print(fmt("❌ %s",k)); fails=fails+1 -- update fails counter
        else print(fmt("✅ %s",k)) end end end    -- check for rogue globals
  for k,v in pairs(_ENV) do 
    if not b4[k] then print(fmt("#W ?%s %s",k,type(v))) end end 
  os.exit(fails) end

---------------------------------------
local SOME=obj"SOME"
function SOME:new(max)
  self.n,self.ok,self._has,self.max = 0,false,{},max or the.Some end

function SOME:add(x)
  if x ~= "?" then
    local pos
    self.n = self.n+1
    if     #self._has < self.max          then pos= 1 + #self._has 
    elseif rand()     < self.max/self.max then pos= self._has end 
    if pos then
      self.ok=false
      self._has[pos] = x end end end

local NUM=obj"NUM"
function NUM:new(at,s)
  self.at,self.s  = at or 0,s or ""
  self.n,self.has = 0,SOME()
  self.w          = (s or ""):find"-$" and -1 or 1
  self.lo, self.hi= math.huge, -math.huge end

function NUM:add(x)
  if x ~="?" then
    self.n = self.n + 1
    self.has:add(x)
    self.lo = math.min(self.lo,x)
    self.hi = math.max(self.hi,x) end end

function NUM:discretize(n) --> num; discretize `Num`s,rounded to (hi-lo)/bins
  local tmp = (self.hi - self.lo)/(the.bins - 1)
  return self.hi == self.lo and 1 or math.floor(n/tmp + .5)*tmp end 

local SYM=obj"SYM"
function SYM:new(at ,s)
  self.at,self.s  = at or 0,s or ""
  self.n,self.has = 0,{} end

function SYM:add(x)
  if x ~="?" then
    self.n = self.n + 1
    self.has[x] = 1+ (self.has[x] or 0) end end

local COLS=obj"COLS"
function COLS:new(t)
  self.names=t
  self.all,self.x,self.y,self.klass = {},{},{},nil
  for n,s in pairs(t) do
    local col = push(self.all, s:find"^[A-Z]+" and NUM(n,s) or SYM(n,s))
    if not s:find"X$" then
      push(s:find"[!+-]$" and self.y or self.x, col)
      if s:find"!$" then self.klass=col end end end end

function COLS:add(t)
  for _,cols in pairs{self.x,self.y} do
    for _,col in pairs(cols) do
      col:add(t[col.at]) end end 
  return t end

local DATA=obj"DATA"
function DATA:new(src)
  self._rows, self.cols = {},nil
  local function row(t) self:add(t) end
  if type(src)=="string" then csv(src,row) else map(src or {},row) end end

function DATA:add(t)
  if not self.cols then self.cols=COLS(t) else 
    self.cols:add(t)
    push(self._rows,t) end end

-------------------
-- ## Start up

local eg={}
function eg.main()
  print(DATA(the.file)) end

runs(the,eg)
